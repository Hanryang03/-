<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>아쿠아 리서전스 (Aqua Resurgence)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Pretendard', sans-serif; touch-action: none; }
        canvas { display: block; image-rendering: pixelated; }
        #ui-layer, .modal-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: white; }
        .modal-layer { background: rgba(0, 0, 0, 0.85); display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 100; }
        .pixel-box { background: #001a33; border: 4px double #00d4ff; padding: 20px; width: 90%; max-width: 450px; box-shadow: 8px 8px 0 #004466; }
        .pixel-button { background: #004466; border: 2px solid #00d4ff; padding: 10px; width: 100%; text-align: left; margin-bottom: 10px; font-size: 13px; cursor: pointer; color: white; }
        .pixel-button:hover { background: #006699; }
        .pixel-button:disabled { opacity: 0.4; cursor: not-allowed; }
        .bar-container { width: 100px; height: 8px; background: rgba(255, 255, 255, 0.1); border: 1px solid #444; margin-top: 2px; }
        .bar-fill { height: 100%; transition: width 0.1s linear; }
        #minimap-container { width: 110px; height: 110px; background: rgba(0, 0, 0, 0.85); border: 3px solid #00d4ff; position: relative; border-radius: 50%; overflow: hidden; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 10px #00d4ff; }
        #action-btn, #attack-btn { position: absolute; bottom: 45px; right: 30px; width: 75px; height: 75px; color: white; font-size: 11px; font-weight: bold; display: flex; align-items: center; justify-content: center; pointer-events: auto; user-select: none; text-align: center; border: 4px double white; background: #004466; }
        #attack-btn { background: #800; right: 125px; }
        #interior-hint { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 212, 255, 0.2); padding: 10px 20px; border: 2px solid #00d4ff; font-size: 12px; pointer-events: none; display: none; z-index: 90; text-transform: uppercase; font-weight: bold; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="interior-hint">조종석 뷰 - [P]를 눌러 밖을 보기</div>

    <!-- 시설 상호작용 모달 -->
    <div id="base-modal" class="modal-layer">
        <div class="pixel-box">
            <h2 id="modal-title" class="text-xl font-bold mb-4 text-cyan-400 uppercase">FACILITY</h2>
            <div id="modal-content" class="text-sm mb-6 space-y-3 max-h-[350px] overflow-y-auto pr-2"></div>
            <button onclick="window.closeUI()" class="w-full py-2 bg-red-900 border-2 border-white font-bold text-xs uppercase">닫기 [ESC]</button>
        </div>
    </div>

    <!-- UI 레이어 -->
    <div id="ui-layer">
        <div class="flex justify-between items-start p-3">
            <div class="flex flex-col gap-3">
                <div id="minimap-container"><canvas id="minimapCanvas" width="110" height="110"></canvas></div>
                <div id="stat-gauges" class="bg-black/80 p-2 border border-white/20">
                    <div><span class="text-[8px] font-bold text-blue-300">OXYGEN</span><div class="bar-container"><div id="ox-bar" class="bar-fill bg-blue-400"></div></div></div>
                    <div class="mt-1"><span class="text-[8px] font-bold text-yellow-300">BATTERY</span><div class="bar-container"><div id="bat-bar" class="bar-fill bg-yellow-400"></div></div></div>
                </div>
            </div>
            <div class="text-right">
                <div id="relic-count-ui" class="text-lg font-bold text-cyan-400">Relics: 0</div>
                <div id="bio-count-ui" class="text-sm font-bold text-green-400">Bio Data: 0</div>
                <div id="depth-text" class="text-[10px] text-gray-400 font-mono tracking-widest uppercase">Surface</div>
            </div>
        </div>
        <div id="attack-btn">ATTACK (\)</div>
        <div id="action-btn">ACTION (F)</div>
    </div>

    <div id="status-modal" class="modal-layer">
        <div class="pixel-box text-center">
            <h2 class="text-2xl font-bold mb-2 text-red-500">통신 두절</h2>
            <p class="text-sm mb-6 text-gray-300">잠수정의 선체가 파손되었습니다.</p>
            <button onclick="location.reload()" class="w-full py-3 bg-cyan-600 text-white font-bold uppercase">재접속</button>
        </div>
    </div>

<script>
    /**
     * 1. 전역 시스템 변수
     */
    const PIXEL_SIZE = 4;
    const worldSize = { width: 8000, height: 25000 };
    const SEA_LEVEL = 800;
    const CHARACTER_IMAGE_ID = "1EzD_xHf3dWXXiIfnH89p4ymOabzC6kZD";

    let canvas, ctx, miniCanvas, miniCtx;
    let baseModal, modalTitle, modalContent;
    let lastFrameTime = performance.now();
    let width, height;
    let damageFlash = 0;
    const keys = {};

    let globalState = {
        relics: 0, bioData: 0,
        upgrades: { weapon: 1, gear: 1, engine: 1, tank: 1 },
        inventory: ["기본 권총", "노후된 잠수복"]
    };

    let player = {
        x: 4000, y: 780, vx: 0, vy: 0, angle: 0,
        relics: 0, fishes: 0, oxygen: 100, battery: 100,
        maxOxygen: 100, maxBattery: 100, radius: 14, 
        onBoard: false, currentZoom: 2.0, targetZoom: 2.0,
        lastFaceDir: 1, attackHoldTime: 0, isInPocket: false, 
        ambientSight: 140, sightDistance: 450, sightAngle: Math.PI / 4,
        isInvincible: false, isLaserFiring: false, viewMode: 'external'
    };

    let subPos = { x: 4000, y: 810, radius: 25 }; 
    let relics = [], seaFishes = [], terrains = [], airPockets = [], bubbles = [], projectiles = [];
    const assets = { player: new Image(), loaded: { player: false } };

    const FACILITIES = [
        { id: 'weapon', name: '무기 제작소', color: '#ff4444', desc: '더 깊은 곳의 괴물들을 상대하기 위한 무기 연구.' },
        { id: 'gear', name: '장비 제작소', color: '#44ff44', desc: '잠수복의 내압 성능과 산소 효율 개선.' },
        { id: 'storage', name: '인벤토리', color: '#ffff44', desc: '수집한 고대 유물과 장비 목록.' },
        { id: 'aquarium', name: '수족관', color: '#4444ff', desc: '생포한 심해 생물의 표본을 관찰하고 데이터를 추출.' },
        { id: 'maintenance', name: '잠수함 정비실', color: '#ff44ff', desc: '잠수함의 엔진 출력과 배터리를 최적화합니다.' }
    ];

    /**
     * 2. 오디오 시스템
     */
    let audioCtx = null;
    const SFX = {
        play(freq, type, duration, volume = 0.1) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(volume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + duration);
        },
        shoot() { this.play(800, 'square', 0.1, 0.05); },
        hit() { this.play(80, 'sawtooth', 0.2, 0.1); },
        collect() { this.play(1200, 'square', 0.1, 0.05); },
        ui() { this.play(600, 'sine', 0.1, 0.05); },
        laser() { this.play(400 + Math.random()*200, 'sawtooth', 0.03, 0.02); },
        interior() { this.play(300, 'sine', 0.3, 0.1); }
    };
    function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

    /**
     * 3. 전역 바인딩 함수 (UI)
     */
    window.toggleDevBar = function() {
        const bar = document.getElementById('dev-bar'); const toggle = document.getElementById('dev-toggle');
        if (bar && toggle) { const isOpen = bar.style.left === '0px'; bar.style.left = isOpen ? '-250px' : '0px'; toggle.style.left = isOpen ? '0px' : '250px'; }
    };
    window.closeUI = function() { document.getElementById('base-modal').style.display = 'none'; SFX.ui(); };
    window.openUI = function(facility) {
        initAudio(); SFX.ui();
        const modal = document.getElementById('base-modal');
        modal.style.display = 'flex';
        document.getElementById('modal-title').innerText = `[ ${facility.name} ]`;
        let totalR = globalState.relics + player.relics;
        let html = `<p class="text-[10px] text-gray-400 mb-4">${facility.desc}</p>`;
        if (facility.id === 'weapon') html += `<button onclick="window.craft('weapon', 5)" class="pixel-button" ${totalR < 5 ? 'disabled' : ''}>무기 공격력 강화 (Relic x5) - Lv.${globalState.upgrades.weapon}</button>`;
        else if (facility.id === 'gear') html += `<button onclick="window.craft('tank', 3)" class="pixel-button" ${totalR < 3 ? 'disabled' : ''}>산소 탱크 확장 (Relic x3) - Lv.${globalState.upgrades.tank}</button>`;
        else if (facility.id === 'storage') html += `<p class="text-yellow-400 font-bold">보유 유물: ${totalR}개</p><ul class="text-[11px] mt-2">${globalState.inventory.map(i=>`<li>- ${i}</li>`).join('')}</ul>`;
        else if (facility.id === 'maintenance') html += `<button onclick="window.craft('engine', 4)" class="pixel-button" ${totalR < 4 ? 'disabled' : ''}>엔진 효율 강화 (Relic x4) - Lv.${globalState.upgrades.engine}</button>`;
        else html += `<p>데이터 수집 중: ${globalState.bioData + player.fishes} Bio Data</p>`;
        document.getElementById('modal-content').innerHTML = html;
    };
    window.craft = function(type, cost) {
        let total = globalState.relics + player.relics;
        if (total >= cost) {
            if (player.relics >= cost) player.relics -= cost; else { globalState.relics -= (cost - player.relics); player.relics = 0; }
            globalState.upgrades[type === 'tank' ? 'tank' : (type === 'engine' ? 'engine' : 'weapon')]++;
            if (type === 'tank') player.maxOxygen += 50;
            SFX.collect(); window.openUI(FACILITIES.find(f => f.id === (type === 'tank' ? 'gear' : (type === 'engine' ? 'maintenance' : 'weapon'))));
        }
    };
    window.devAddRelics = (amt) => { globalState.relics += amt; };
    window.devRefill = () => { player.oxygen = player.maxOxygen; player.battery = player.maxBattery; };
    window.devInvincible = () => { player.isInvincible = !player.isInvincible; };
    window.devTeleport = (x, y) => { player.x = x; player.y = y; player.vx = 0; player.vy = 0; };

    /**
     * 4. 게임 엔진 코어
     */
    function init() {
        canvas = document.getElementById('gameCanvas'); ctx = canvas.getContext('2d');
        miniCanvas = document.getElementById('minimapCanvas'); miniCtx = miniCanvas.getContext('2d');
        baseModal = document.getElementById('base-modal');
        resize(); setupInputs(); generateWorld(); loadAssets();
        requestAnimationFrame(gameLoop);
    }

    function loadAssets() {
        if (CHARACTER_IMAGE_ID) {
            assets.player.crossOrigin = "anonymous";
            assets.player.src = `https://drive.google.com/uc?export=view&id=${CHARACTER_IMAGE_ID}`;
            assets.player.onload = () => assets.loaded.player = true;
        }
    }

    function checkVisibility(tx, ty) {
        if (player.y <= SEA_LEVEL + 50 || player.isInPocket) return true;
        const dx = tx - player.x, dy = ty - player.y, d = Math.sqrt(dx*dx+dy*dy);
        if (d < player.ambientSight - 20) return true;
        if (player.onBoard) {
            const sd = player.isLaserFiring ? player.sightDistance * 1.5 : player.sightDistance;
            if (d < sd) {
                const a = Math.atan2(dy, dx); let diff = Math.abs(a - player.angle);
                if (diff > Math.PI) diff = Math.PI * 2 - diff;
                return diff < player.sightAngle;
            }
        }
        return false;
    }

    function generateWorld() {
        airPockets = [{ x: 2000, y: 5000, radius: 600 }, { x: 6000, y: 15000, radius: 800 }];
        for(let i=0; i<100; i++) relics.push({ x: Math.random()*worldSize.width, y: SEA_LEVEL + 500 + Math.random()*(worldSize.height-SEA_LEVEL-1500), collected: false });
        for(let i=0; i<60; i++) seaFishes.push({ x: Math.random()*worldSize.width, y: SEA_LEVEL + 500 + Math.random()*(worldSize.height-SEA_LEVEL-1500), vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, type: 'glow', hp: 40, maxHp: 40, isAggressive: false, isDead: false, hitEffect: 0, lastAttackTime: 0, color: '#0ff', size: 14 });
        for(let i=0; i<150; i++) terrains.push({ x: Math.random()*worldSize.width, y: SEA_LEVEL + 1000 + Math.random()*(worldSize.height-SEA_LEVEL-2000), radius: 60 + Math.random()*150 });
    }

    function setupInputs() {
        window.addEventListener('keydown', (e) => { 
            keys[e.code] = true; 
            if (e.code === 'KeyF') handleFKey(); 
            if (e.code === 'KeyP') toggleInterior();
            if (e.code === 'Escape') window.closeUI(); 
            if (e.code === 'Backslash' || e.key === '\\') player.isAttackHolding = true; 
        });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; if (e.code === 'Backslash' || e.key === '\\') { fireProjectile(); player.isAttackHolding = false; player.attackHoldTime = 0; } });
        canvas.addEventListener('mousedown', (e) => {
            initAudio(); if (baseModal.style.display === 'flex') return;
            if (player.viewMode === 'interior') {
                const rect = canvas.getBoundingClientRect();
                const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
                const mw = width * 0.15, spacing = (width * 0.75) / 5;
                if (cy > height * 0.3 && cy < height * 0.7) FACILITIES.forEach((f, i) => { const mx = width * 0.1 + i * spacing; if (cx > mx && cx < mx + mw) window.openUI(f); });
            }
        });
    }

    function handleFKey() {
        initAudio();
        const nearSub = Math.sqrt((player.x - subPos.x)**2 + (player.y - subPos.y)**2) < 120;
        const pocket = airPockets.find(p => Math.sqrt((player.x-p.x)**2 + (player.y-p.y)**2) < p.radius);
        if (nearSub || pocket) {
            if (!player.onBoard) { player.onBoard = true; player.targetZoom = 1.0; SFX.ui(); }
            else if (player.y <= SEA_LEVEL + 100 || pocket) { if(player.viewMode === 'interior') return; player.onBoard = false; subPos.x = player.x; subPos.y = player.y; player.targetZoom = 2.0; SFX.ui(); }
        }
        if (player.onBoard) seaFishes.forEach((f, i) => { if (!f.isDead && !f.isAggressive && Math.sqrt((player.x-f.x)**2+(player.y-f.y)**2) < 100) { player.fishes++; seaFishes.splice(i, 1); SFX.collect(); }});
    }

    function toggleInterior() { if (!player.onBoard) return; initAudio(); SFX.interior(); player.viewMode = player.viewMode === 'external' ? 'interior' : 'external'; document.getElementById('interior-hint').style.display = player.viewMode === 'interior' ? 'block' : 'none'; }

    function fireProjectile() {
        if (player.viewMode === 'interior') return;
        const speed = player.onBoard ? 14 : 20; const dmg = 15 * globalState.upgrades.weapon;
        if (player.onBoard) { projectiles.push({ x: player.x, y: player.y, vx: Math.cos(player.angle)*speed, vy: Math.sin(player.angle)*speed, life: 60, damage: dmg, type: 'sub' }); SFX.shoot(); }
        else { if (player.attackHoldTime >= 30) { projectiles.push({ x: player.x, y: player.y, vx: player.lastFaceDir*10, vy: 0, life: 100, damage: dmg*3, type: 'charged' }); player.vx = -player.lastFaceDir * 15; SFX.powerShoot(); } else { projectiles.push({ x: player.x, y: player.y, vx: player.lastFaceDir*speed, vy: 0, life: 40, damage: dmg, type: 'pistol' }); SFX.shoot(); } }
    }

    function update(time) {
        if (baseModal.style.display === 'flex') return;
        const dt = time - lastFrameTime; lastFrameTime = time;
        damageFlash = Math.max(0, damageFlash - 0.05);
        player.currentZoom += (player.targetZoom - player.currentZoom) * 0.05;

        if (player.viewMode === 'external') {
            let dx = 0, dy = 0; if (keys['KeyW'] || keys['ArrowUp']) dy -= 1; if (keys['KeyS'] || keys['ArrowDown']) dy += 1; if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1; if (keys['KeyD'] || keys['ArrowRight']) dx += 1;
            if (dx !== 0 || dy !== 0) { const ms = player.onBoard ? (4.5 + globalState.upgrades.engine*0.5) : 4.5; player.vx = dx * ms; if (player.onBoard || player.isInPocket) player.vy = dy * ms; if (dx !== 0) player.lastFaceDir = dx > 0 ? 1 : -1; player.angle = Math.atan2(dy, dx); } else { player.vx *= 0.7; player.vy *= 0.7; }
        }

        const pocket = airPockets.find(p => Math.sqrt((player.x-p.x)**2 + (player.y-p.y)**2) < p.radius);
        player.isInPocket = !!pocket;

        if (!player.onBoard) { if (player.isInPocket) { player.x += player.vx; player.y += player.vy; } else { player.x = Math.max(subPos.x - 150, Math.min(subPos.x + 150, player.x + player.vx)); player.y = SEA_LEVEL - 20; player.vy = 0; } }
        else { if (!player.isInPocket && player.y + player.vy < SEA_LEVEL + 50) { player.vy = 0; player.y = SEA_LEVEL + 50; } player.x += player.vx; player.y += player.vy; if (player.isAttackHolding && player.viewMode === 'external') { player.attackHoldTime++; if (player.attackHoldTime > 15) { player.isLaserFiring = true; player.vx -= Math.cos(player.angle)*1.5; player.vy -= Math.sin(player.angle)*1.5; player.battery -= 0.2; SFX.laser(); } } else player.isLaserFiring = false; }

        relics.forEach(r => { if (!r.collected && Math.sqrt((player.x-r.x)**2+(player.y-r.y)**2) < 40) { r.collected = true; player.relics++; SFX.collect(); }});
        seaFishes.forEach(f => { if (!f.isDead) { if (f.isAggressive) { const adx = player.x - f.x, ady = player.y - f.y, d = Math.sqrt(adx*adx+ady*ady); f.vx = (adx/d)*5.5; f.vy = (ady/d)*5.5; if (d < player.radius + f.size && Date.now() - f.lastAttackTime > 1000) { if(!player.isInvincible){player.battery -= 10; player.oxygen -= 5; damageFlash = 0.5; SFX.hit();} f.lastAttackTime = Date.now(); } } else { if (Math.random() < 0.02) { f.vx += (Math.random()-0.5)*2; f.vy += (Math.random()-0.5)*1; } f.vx = Math.max(-3, 3, f.vx); f.vy = Math.max(-2, 2, f.vy); } f.x += f.vx; f.y += f.vy; if(f.x<0 || f.x>worldSize.width) f.vx*=-1; if(f.y<SEA_LEVEL+200 || f.y>worldSize.height) f.vy*=-1; projectiles.forEach(p => { if(Math.sqrt((f.x-p.x)**2+(f.y-p.y)**2) < f.size + 10) { f.hp -= p.damage; f.isAggressive = true; f.hitEffect = 1; p.life = 0; SFX.hit(); if(f.hp <= 0) { f.isDead = true; player.fishes++; SFX.collect(); }}}); } else f.y += 2; });
        projectiles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life--; if(p.life<=0) projectiles.splice(i,1); });
        bubbles.forEach((b, i) => { b.x+=b.vx; b.y+=b.vy; b.life-=0.02; if(b.life<=0) bubbles.splice(i,1); });
        if (player.y > SEA_LEVEL + 50 && !player.isInPocket) player.oxygen -= 0.015; else player.oxygen = Math.min(100, player.oxygen + 0.8);
        if (player.oxygen <= 0 && !player.isInvincible) document.getElementById('status-modal').style.display = 'flex';
        
        document.getElementById('ox-bar').style.width = player.oxygen + '%';
        document.getElementById('bat-bar').style.width = player.battery + '%';
        document.getElementById('relic-count-ui').innerText = `Relics: ${globalState.relics + player.relics}`;
        document.getElementById('bio-count-ui').innerText = `Bio Data: ${globalState.bioData + player.fishes}`;
        document.getElementById('depth-text').innerText = player.y > SEA_LEVEL + 50 ? `${Math.floor((player.y-SEA_LEVEL-50)/5)}M` : 'Surface';
        
        const inD = Math.sqrt((player.x - subPos.x)**2 + (player.y - subPos.y)**2) < 120, pk = airPockets.find(p => Math.sqrt((player.x-p.x)**2 + (player.y-p.y)**2) < p.radius), nF = player.onBoard && seaFishes.some(f => !f.isDead && Math.sqrt((player.x-f.x)**2+(player.y-f.y)**2) < 100);
        document.getElementById('action-btn').style.display = (player.viewMode === 'external' && (inD || pk || nF)) ? 'flex' : 'none';
        
        drawMinimap();
    }

    function draw() {
        if (!ctx) return; ctx.fillStyle = "#000"; ctx.fillRect(0, 0, width, height);
        if (baseModal.style.display === 'flex') return;
        if (player.viewMode === 'external') {
            ctx.save(); ctx.translate(width/2, height/2); ctx.scale(player.currentZoom, player.currentZoom); ctx.translate(-player.x, -player.y);
            // 환경
            ctx.fillStyle = "#05050a"; ctx.fillRect(-10000, -5000, 20000, SEA_LEVEL + 5000);
            const seaGrad = ctx.createLinearGradient(0, SEA_LEVEL, 0, worldSize.height); seaGrad.addColorStop(0, '#001a33'); seaGrad.addColorStop(1, '#000000');
            ctx.fillStyle = seaGrad; ctx.fillRect(-10000, SEA_LEVEL, 20000, worldSize.height);
            // 에어포켓 & 유물
            airPockets.forEach(p => { ctx.fillStyle = "rgba(0, 212, 255, 0.1)"; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = "#00d4ff"; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = "#1a1a1a"; ctx.fillRect(p.x-40, p.y-30, 80, 60); });
            relics.forEach(r => { if(!r.collected && checkVisibility(r.x, r.y)) { ctx.fillStyle = "#ff0"; ctx.fillRect(r.x-4, r.y-4, 8, 8); }});
            seaFishes.forEach(f => { if(!checkVisibility(f.x, f.y)) return; ctx.fillStyle = f.isDead ? "#333" : (f.isAggressive ? "#f00" : f.color); ctx.fillRect(f.x-8, f.y-4, 16, 8); });
            if (!player.onBoard) { ctx.fillStyle = "#00d4ff"; ctx.fillRect(subPos.x-30, subPos.y-15, 60, 30); }
            ctx.save(); ctx.translate(player.x, player.y);
            if (player.onBoard) { ctx.rotate(Math.floor(player.angle/(Math.PI/4))*(Math.PI/4)); ctx.fillStyle = "#00d4ff"; ctx.fillRect(-16, -10, 32, 20); } 
            else { ctx.scale(player.lastFaceDir, 1); if (assets.loaded.player) ctx.drawImage(assets.player, -15, -25, 30, 40); else { ctx.fillStyle = "#fff"; ctx.fillRect(-7, -15, 14, 25); } }
            ctx.restore();
            bubbles.forEach(b => { ctx.fillStyle = b.color; ctx.fillRect(b.x, b.y, 2, 2); });
            projectiles.forEach(p => { ctx.fillStyle = "#ff0"; ctx.fillRect(p.x, p.y, 4, 2); });
            ctx.restore();
            // 최상단 깊이 라인
            ctx.save(); ctx.translate(width/2, height/2); ctx.scale(player.currentZoom, player.currentZoom); ctx.translate(-player.x, -player.y);
            for(let d=100; d<4000; d+=100) { const ly = SEA_LEVEL + d*5; ctx.strokeStyle = "rgba(0, 212, 255, 0.3)"; ctx.setLineDash([8, 8]); ctx.beginPath(); ctx.moveTo(0, ly); ctx.lineTo(worldSize.width, ly); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle = "#00d4ff"; ctx.font = "bold 10px monospace"; ctx.fillText(`${d}M`, 20, ly - 5); }
            ctx.restore();
            if (damageFlash > 0) { ctx.fillStyle = `rgba(255, 0, 0, ${damageFlash})`; ctx.fillRect(0, 0, width, height); }
            if (player.y > SEA_LEVEL && !player.isInPocket) drawFog();
        } else {
            // 내부 조종석
            ctx.fillStyle = "#001a33"; ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = "#00d4ff"; ctx.lineWidth = 10; ctx.strokeRect(10, 10, width-20, height-20);
            const mw = width * 0.15, mh = height * 0.4, sp = (width * 0.75) / 5;
            FACILITIES.forEach((f, i) => { const mx = width * 0.1 + i * sp, my = height * 0.3; ctx.fillStyle = "#000"; ctx.fillRect(mx, my, mw, mh); ctx.strokeStyle = f.color; ctx.lineWidth = 2; ctx.strokeRect(mx, my, mw, mh); ctx.fillStyle = f.color; ctx.font = "bold 10px monospace"; ctx.textAlign = "center"; ctx.fillText(f.id.toUpperCase(), mx + mw/2, my + 30); ctx.fillText(f.name, mx + mw/2, my + mh - 20); ctx.fillStyle = "white"; ctx.fillText("[CLICK]", mx + mw/2, my + mh/2); });
            ctx.fillStyle = "#00d4ff"; ctx.font = "bold 14px monospace"; ctx.textAlign = "center"; ctx.fillText("SUBMARINE COMMAND CENTER", width/2, 60);
        }
    }

    function drawFog() {
        ctx.save(); const m = document.createElement('canvas'); m.width = width; m.height = height; const mc = m.getContext('2d');
        mc.fillStyle = "rgba(0,0,0,0.92)"; mc.fillRect(0, 0, width, height); mc.globalCompositeOperation = "destination-out";
        const lx = width/2, ly = height/2, rad = player.ambientSight * player.currentZoom;
        const g = mc.createRadialGradient(lx, ly, 20, lx, ly, rad); g.addColorStop(0, "white"); g.addColorStop(1, "transparent");
        mc.fillStyle = g; mc.beginPath(); mc.arc(lx, ly, rad, 0, Math.PI*2); mc.fill();
        ctx.drawImage(m, 0, 0); ctx.restore();
    }

    function drawMinimap() {
        if (!miniCtx) return; miniCtx.clearRect(0, 0, 110, 110); miniCtx.save(); miniCtx.beginPath(); miniCtx.arc(55, 55, 55, 0, Math.PI * 2); miniCtx.clip();
        const ms = 0.05, cx = 55, cy = 55; miniCtx.fillStyle = "#000a15"; miniCtx.fillRect(0, 0, 110, 110);
        const rY = cy + (SEA_LEVEL - player.y) * ms; miniCtx.fillStyle = "#1a1a1a"; miniCtx.fillRect(0, 0, 110, rY);
        airPockets.forEach(p => { const rx = cx + (p.x - player.x) * ms, ry = cy + (p.y - player.y) * ms; miniCtx.strokeStyle = "#00d4ff"; miniCtx.beginPath(); miniCtx.arc(rx, ry, p.radius * ms, 0, Math.PI*2); miniCtx.stroke(); });
        miniCtx.fillStyle = "#ff0"; relics.forEach(r => { if (!r.collected) { const rx = cx + (r.x - player.x) * ms, ry = cy + (r.y - player.y) * ms; miniCtx.fillRect(rx-1, ry-1, 2, 2); }});
        miniCtx.fillStyle = player.onBoard ? "#0df" : "#fff"; miniCtx.beginPath(); miniCtx.arc(cx, cy, 3, 0, Math.PI * 2); miniCtx.fill();
        miniCtx.restore();
    }

    function resize() { width = window.innerWidth; height = window.innerHeight; canvas.width = width; canvas.height = height; }
    function gameLoop(time) { update(time); draw(); requestAnimationFrame(gameLoop); }
    window.onload = init;
</script>
</body>
</html>